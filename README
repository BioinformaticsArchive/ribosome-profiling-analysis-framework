RIBOSOME PROFILING PROJECT, DISCOVERING TRIPLET PERIODICITY AND ALTERNATIVE ORFs
================================================================================

WORKFLOW
--------------------------------------------------------------------------------
If you're doing alignment on the genome only, skip to 7).

1) If you're doing alignment on the transcriptome, you'll get positions based on
the start of the transcript, instead of the start of the open reading frame.
The method used here to do this mapping, is Mutalyzer. For this, we first need
to get from transcriptome positions, to genomic positions. Since the transcrip-
tome sequences do not always align well to the genome, first the transcriptome
reference sequence needs to be filtered for transcripts that do not support this
alignment. For all the other transcripts, you need a file that indicates the
location of the exons of the transcripts on the genome. The NCBI file is not
usable, and Mutalyzer can not do this step either. See the help file
help/mm10_transcript_positions_create.txt for more information.

Usage: ./mm10_transcript_positions_create.php TRANSCRIPTOME_ALIGNMENT_SAM_FILE

Produces:
- mm10_transcript_positions.txt
  Contains the genomic locations of all exons of each useful transcript.
- transcriptome_alignment_unsupported_transcripts.txt
  Contains all unsupported transcripts and the reasons for rejection.



2) Also interesting to know is which transcripts might pose problems when
aligning to the genome. These are the transcripts where close to the translation
start site an intron is located. This information can not be deduced from the
transcript-to-genome alignment SAM file from step 1, since that does not
indicate where the translation start site is located. For this, we download a
file from the NCBI that has the annotation of exons and the translated region
for each transcript:
ftp://ftp.ncbi.nih.gov/genomes/M_musculus/mapview/seq_gene.md.gz
The find_distance_to_ATG.php script extracts this information and creates two
files; one with problematic transcripts, sorted on the distance to the closest
intron, and one file with transcripts where no UTR is annotated so where the
distance to the 5' intron is unknown.
A distance of 15 bases to the ATG is currently the default threshold.

Usage: ./find_intron_distance_to_ATG.php path_to_seq_gene.md
Produces:
- seq_gene.md.distance_intron_to_ATG.txt
  Lists all transcripts where the distance of the intron to the ATG is 15 or
  less (distance is configurable by editing the file).
- seq_gene.md.distance_intron_to_ATG_errors.txt
  Lists all transcripts that have no UTR annotated, thus the 5' distance to an
  intron is unknown. For all these transcripts, the 3' distance is safe (> 15).



3) After doing the alignment of the ribosome profiling reads on the transcrip-
tome, you end up with SAM files.
The SAM files are first packed, reducing them in size and grouping the reads
together to generate a file that sums the coverage per transcript per position.
For this, use the pack_sam_files.php file.
Usage: ./pack_sam_files.php SAM_FILE1 [SAM_FILE2 [SAM_FILE3 [...]]]

Produces:
- For each given SAM file, a SAM.packed file.
  Contains the transcript ID, the position relative to the start of the tran-
  script, and the total coverage for that position, i.e. the number of reads
  aligned starting at this position.



4) The packed SAM files can be used to run some statistics. Currently available
is packed_sam2coverage_per_gene.php.
Usage: ./packed_sam2coverage_per_gene.php path_to_mm10_gene_list.txt \
           PACKED_SAM_FILE1 [ PACKED_SAM_FILE2 [ ... ]]

Produces:
- One file which name depends on the given SAM files, ending in the suffix
  .coverage_per_gene.txt, per SAM file, mentioned which transcripts can not be
  matched to a gene, listing the top 5 unknown transcripts based on their cove-
  rage and finally, a large table where the samples are presented as columns,
  and on each line the genes are given with the coverage in each sample. The
  genes are sorted on total coverage in all samples together.

Other statistics can be run directly on the packed SAM files, for instance how
many reads are mapped to non-coding reads.



5) The packed SAM files are used to generate Wiggle files. For this, use the
packed_sam2wiggle.php script, which needs the transcript positions file descri-
bed in 1).
Usage: ./packed_sam2wiggle.php TRANSCRIPT_POSITIONS_FILE \
           PACKED_SAM_FILE1 [PACKED_SAM_FILE2 [PACKED_SAM_FILE3 [...]]

This script creates 4 Wiggle files per SAM file; F unfiltered, F filtered (NR
and XR removed), R unfiltered, and R filtered.



6) Optionally, if genome alignment has been done as well as transcriptome align-
ment, the Wiggle files from both alignments can be merged together. This is done
using the "wiggelen" package written by Martijn Vermaat and Jeroen Laros.
For detailed information, see the help file help/merge_wigglefiles.txt.



7) Wiggle files are converted to Mutalyzer position converter batch files using
the wig2batchfile.php script.
Usage: ./wig2batchfile.php WIG_FILE
It can create one mutalyzer file for multiple Wiggle files, but the analysis
script does not support that, so then they would need to be split afterwards.



8) The position converter batch files are manually loaded into Mutalyzer:
https://mutalyzer.nl/batchPositionConverter
or
https://test.mutalyzer.nl/batchPositionConverter
(this test installation is slightly faster because it doesn't have much traffic,
 but it doesn't support emailing you the link to the results)



9) When done, the results are downloaded from Mutalyzer. If you're not sure
anymore which results file belongs to which batchfile, you can match these files
by using the match_mutalyzer_output_to_batchfile.sh script.
Usage:
./match_mutalyzer_output_to_batchfile.sh <MUTALYZER_OUTPUT_FILES> <BATCH_FILES>

The results files can be analyzed using the analyze_codon_positions.php script,
that checks if the ribosomes have indeed been stopped at the start sites.
Usage:
./analyze_codon_positions.php MUTALYZER_FILE WIGGLE_FILE GENE_LIST_FILE STRAND

Example:
./analyze_codon_positions.php F.wig5_mutalyzer_batchfile_results.txt F.wig5 \
  mm10_gene_list.txt F
(Valid values for Strand: +, -, F and R)

The script does the following things:
+ Read out the coverage information from the Wiggle file
+ Read the gene list to find out which genes (transcripts, actually) are on
  which strand
+ Read the Mutalyzer result file to see which locations map to which
  transcripts, determining the position within the transcript
  * Filter low coverage positions (< 3)
  * Mappings on non-coding transcripts are ignored
  * Mappings on transcripts on the other strand are ignored
  * Filter positions without transcript mapping
  * Filter positions with only intronic mapping
  * Filter positions too far from transcript start or stop sites
    (> 500bp)
  * The remaining possible mappings are processed.
    Please note that the "coding region" is defined as the region starting at
    -15 nucleotides from the ATG to the end of the open reading frame.
    Please note that this script does not see the difference between the UTR and
    the intergenic sequence. Both are referred to as "UTR mappings".
    - 5' UTR or 3' UTR mappings, while mappings to the coding region are also
      available, are discarded.
    - If there are 5' UTR and 3' UTR mappings, but none in the coding
      region, we assume an intergenic situation and if one of the two
      positions is clearly closer to the coding region than the
      other (> 100bp), then the closest position is picked.
      If not, the position is reported.
    - After this, all mappings are counted by their coverage and
      reported.

Possible to do:
- Multiple 5' UTR *or* multiple 3' UTR mappings are all counted if these
are the only mappings. Perhaps we should pick the closest, like as if
both UTR mappings were present.



10) Now, it's time to try and find alternative Open Reading Frames (ORFs). The
find_ORFs.php script tries to identify "peaks" in the coverage pattern as
alternative open reading frame starts, depending on the coverage of the
surrounding region.
Usage:
./find_ORFs.php <MUTALYZER_RESULTS> <WIGGLE_FILE> <GENE_LIST_FILE> <STRAND>

Example:
./find_ORFs.php F.wig5_mutalyzer_batchfile_results.txt F.wig5 \
  mm10_gene_list.txt F
(Valid values for Strand: +, -, F and R)

The script does the following things:
+ Read out the coverage information from the Wiggle file
+ Read the gene list to find out which genes (transcripts, actually) are on
  which strand
+ Read the Mutalyzer result file to see which locations map to which
  transcripts, determining the position within the transcript
  * Filter low coverage positions (< 3)
  * Mappings on non-coding transcripts are ignored
  * Mappings on transcripts on the other strand are ignored
  * Transcripts not in the gene list are ignored and reported (so they could be
    fixed == added to the gene info file)
  * Filter positions without transcript mapping
  * Filter positions with only intronic mapping
  * Filter positions too far from transcript start or stop sites (> 500bp)
  * The remaining possible mappings are processed.
    Please note that the "coding region" is defined as the region starting at
    -15 nucleotides from the ATG to the end of the open reading frame.
    Please note that this script does not see the difference between the UTR and
    the intergenic sequence. Both are referred to as "UTR mappings".
    - 3' UTR mappings, while mappings to the coding region or in the 5' UTR are
      also available, are discarded.
    - After this, all positions are stored, per gene, for the next step.
+ Peaks are searched for by walking through the positions, starting upstream.
  Each position, with at least a coverage of 10, is analyzed.
  * Its coverage should be higher than that of the positions located 3, 6, 9, 12
    and 15 nucleotides upstream of it.
  * It should show a triplet periodicity and a clear "harringtonine pattern":
    - The two other nucleotides in the possible codon, so the two nucleotides
      downstream of the position we're analyzing, should not have an average
      coverage higher than 20% of the position's coverage.
    - The following 5 codons should also not have a higher maximum coverage than
      this position's coverage.
    - If any of the following 5 codons have a maximum coverage higher than 10%
      of the coverage of the position we're analyzing, that codon must not show
      a conflicting triplet periodicity pattern (see first point above).
  * If all these rules apply, the position is stored as a possible ORF start,
    and the analysis is continued 5 codons downstream, but again per nucleotide
    and thus allowing ORF start sites in any frame.
  * We currently assume that this will automatically filter out the background
    found at the end of some transcripts. This background is possible on
    transcripts with a length of 5K or higher, since harringtonine was applied
    for 5 minutes and translation speed is about 5.6 codons per second according
    to the literature (5.6 * 3 * 5 * 60 = 5040 nucleotides).
+ Per gene, from all its found possible ORF starts, we will take the one with
  the highest coverage as a reference, and discard any other candidate ORF
  starting points that do not have at least a coverage (on that position) of 10%
  of the reference (highest candidate).
+ All remaining candidate ORF starting points will be reported.
+ Problem: If two ORF starts are apart by less than 5 codons, this procedure
  will either not detect one of the two, or reject both because of each other's
  presence (most likely in the case of two ORFs in a different frame). We can
  decrease the required distance of 5 codons, if we believe that ORFs are not
  detected because of this.
+ Problem: Because of the background found in some longer transcripts, we will
  probably not pick up any ORF start sites within the affected region that use a
  different frame than the background, because the conflicting triplet
  periodicity pattern makes the algorithm reject the candidate. Analyzing the
  pattern in the background separately may in fact detect these ORF start sites.
  Please note that ORF start sites in any frame within 5KB of the primary ORF
  can still be detected, because they are not affected by the background noise.
+ Problem: Mutalyzer describes positions after the stop codon with an asterisk
  followed by the distance to the stop codon, e.g. *3. Since this script does
  not know the transcript lengths at the moment, it is unaware of the distance
  between a position in the coding region (e.g. 4623) and a position after the
  stop codon. Therefore, the checks of the coverage of the surrounding positions
  of a candidate translation start site will be incorrect or not be possible
  when this site is located around the annotated stop codon.
  This may cause false positives around the translation stop site, but not false
  negatives.
+ Genes that have no candidate peaks left, are ignored.
+ For all genes remaining, the positions of the candidate ORF start sites are
  reported relative to all known transcripts of the gene in question. The
  original number of positions with high coverage (>10) is mentioned along with
  the number of remaining candidate ORF start sites.
  Results are displayed as: genomic position, coverage, position on transcript.
  The last column may be repeated, depending on the number of known transcripts.
+ Additionally, a separate file reports all candidate peaks found at a position
  higher than 5Kb from a known ORF start site, so they can easily be checked
  more thoroughly if they are false positives.

Possible to do:
- Actually implement the filtering in the coding region? Is the proposed method
  OK?
- Filtering in the coding region against background measured per frame, so we
  can find alternative frames?



11) Now, the ORF files need to be grouped, per strand (F and R). The
merge_ORF_files.php script merges the files for you into one summary file, but
does not take care of the strands, so you need to make sure you don't mix
forward and reverse files with each other.
Usage:
./merge_ORF_files.php ORF_FILE1 [ORF_FILE2 [ORF_FILE3 [...]]]

Example:
./merge_ORF_files.php *.F.*_ORF_analysis_results.txt

The script analyzes the file names to isolate the sample IDs. It assumes that
the sample IDs are the only differences between the input file names. The sample
IDs are also used in the headers of the output.

While grouping, it ignores the positions of the peaks on the transcripts. It
only reports the chromosomal position, per sample the coverage, and then as a
last column the gene name.

NOTE: When this script reports a coverage of 0, it simply means the position was
not recognized as a translation start site in that sample. The actual measured
coverage in that sample may not at all be 0.

Example output:
# Chromosome    Position    A1    A2    A3    C1    C2    C3    Gene
chr1            4857920     32    14    27     0     0    10    Tcea1
chr1            4857929     24     0    24     0     0     0    Tcea1

