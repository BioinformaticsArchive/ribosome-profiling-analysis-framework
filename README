RIBOSOME PROFILING PROJECT, DISCOVERING TRIPLET PERIODICITY AND ALTERNATIVE ORFs
================================================================================

WORKFLOW
--------------------------------------------------------------------------------
If you're doing alignment on the genome only, skip to 7).

1) If you're doing alignment on the transcriptome, you'll get positions based on
the start of the transcript, instead of the start of the open reading frame.
The method used here to do this mapping, is Mutalyzer. For this, we first need
to get from transcriptome positions, to genomic positions. Since the transcrip-
tome sequences do not always align well to the genome, first the transcriptome
reference sequence needs to be filtered for transcripts that do not support this
alignment. For all the other transcripts, you need a file that indicates the
location of the exons of the transcripts on the genome. The NCBI file is not
usable, and Mutalyzer can not do this step either. See the help file
help/mm10_transcript_positions_create.txt for more information.

Usage: ./mm10_transcript_positions_create.php TRANSCRIPTOME_ALIGNMENT_SAM_FILE

Produces:
- mm10_transcript_positions.txt
  Contains the genomic locations of all exons of each useful transcript.
- transcriptome_alignment_unsupported_transcripts.txt
  Contains all unsupported transcripts and the reasons for rejection.



2) Also interesting to know is which transcripts might pose problems when
aligning to the genome. These are the transcripts where close to the translation
start site an intron is located. This information can not be deduced from the
transcript-to-genome alignment SAM file from step 1, since that does not
indicate where the translation start site is located. For this, we download a
file from the NCBI that has the annotation of exons and the translated region
for each transcript:
ftp://ftp.ncbi.nih.gov/genomes/M_musculus/mapview/seq_gene.md.gz
The find_distance_to_ATG.php script extracts this information and creates two
files; one with problematic transcripts, sorted on the distance to the closest
intron, and one file with transcripts where no UTR is annotated so where the
distance to the 5' intron is unknown.
A distance of 15 bases to the ATG is currently the default threshold.

Usage: ./find_intron_distance_to_ATG.php path_to_seq_gene.md
Produces:
- seq_gene.md.distance_intron_to_ATG.txt
  Lists all transcripts where the distance of the intron to the ATG is 15 or
  less (distance is configurable by editing the file).
- seq_gene.md.distance_intron_to_ATG_errors.txt
  Lists all transcripts that have no UTR annotated, thus the 5' distance to an
  intron is unknown. For all these transcripts, the 3' distance is safe (> 15).



3) After doing the alignment of the ribosome profiling reads on the transcrip-
tome, you end up with SAM files.
The SAM files are first packed, reducing them in size and grouping the reads
together to generate a file that sums the coverage per transcript per position.
For this, use the pack_sam_files.php file.
Usage: ./pack_sam_files.php SAM_FILE1 [SAM_FILE2 [SAM_FILE3 [...]]]

Produces:
- For each given SAM file, a SAM.packed file.
  Contains the transcript ID, the position relative to the start of the tran-
  script, and the total coverage for that position, i.e. the number of reads
  aligned starting at this position.



4) The packed SAM files can be used to run some statistics. Currently available
is packed_sam2coverage_per_gene.php.
Usage: ./packed_sam2coverage_per_gene.php path_to_mm10_gene_list.txt \
           PACKED_SAM_FILE1 [ PACKED_SAM_FILE2 [ ... ]]

Produces:
- One file which name depends on the given SAM files, ending in the suffix
  .coverage_per_gene.txt, per SAM file, mentioned which transcripts can not be
  matched to a gene, listing the top 5 unknown transcripts based on their cove-
  rage and finally, a large table where the samples are presented as columns,
  and on each line the genes are given with the coverage in each sample. The
  genes are sorted on total coverage in all samples together.

Other statistics can be run directly on the packed SAM files, for instance how
many reads are mapped to non-coding reads.



5) The packed SAM files are used to generate Wiggle files. For this, use the
packed_sam2wiggle.php script, which needs the transcript positions file descri-
bed in 1).
Usage: ./packed_sam2wiggle.php TRANSCRIPT_POSITIONS_FILE \
           PACKED_SAM_FILE1 [PACKED_SAM_FILE2 [PACKED_SAM_FILE3 [...]]

This script creates 4 Wiggle files per SAM file; F unfiltered, F filtered (NR
and XR removed), R unfiltered, and R filtered.



6) Optionally, if genome alignment has been done as well as transcriptome align-
ment, the Wiggle files from both alignments can be merged together. This is done
using the "wiggelen" package written by Martijn Vermaat and Jeroen Laros.
For detailed information, see the help file help/merge_wigglefiles.txt.



7) Wiggle files are converted to Mutalyzer position converter batch files using
the wig2batchfile.php script.
Usage: ./wig2batchfile.php WIG_FILE
It can create one mutalyzer file for multiple Wiggle files, but the analysis
script does not support that, so then they would need to be split afterwards.



8) The position converter batch files are manually loaded into Mutalyzer:
https://test.mutalyzer.nl/batchPositionConverter



9) When done, the results are downloaded from Mutalyzer. If you're not sure
anymore which results file belongs to which batchfile, you can match these files
by using the match_mutalyzer_output_to_batchfile.sh script.
Usage:
./match_mutalyzer_output_to_batchfile.sh <MUTALYZER_OUTPUT_FILES> <BATCH_FILES>

The results files can be analyzed using the analyze_codon_positions.php script,
that checks if the ribosomes have indeed been stopped at the start sites.
Usage:
./analyze_codon_positions.php MUTALYZER_FILE WIGGLE_FILE GENE_LIST_FILE STRAND

Example:
./analyze_codon_positions.php F.wig5_mutalyzer_batchfile_results.txt F.wig5 \
  mm10_gene_list.txt F
(Valid values for Strand: +, -, F and R)

The script does the following things:
+ Read out the coverage information from the Wiggle file
+ Read the gene list to find out which genes (transcripts, actually) are on
  which strand
+ Read the Mutalyzer result file to see which locations map to which
  transcripts, determining the position within the transcript
  * Filter low coverage positions (< 3)
  * Mappings on non-coding transcripts are ignored
  * Mappings on transcripts on the other strand are ignored
  * Filter positions without transcript mapping
  * Filter positions with only intronic mapping
  * Filter positions too far from transcript start or stop sites
    (> 500bp)
  * The remaining possible mappings are processed.
    - 5' UTR or 3' UTR mappings, while exonic mappings are also
      available, are discarded.
    - If there are 5' UTR and 3' UTR mappings, but none in the exon
      region, we assume an intergenic situation and if one of the two
      positions is clearly closer to the translated region than the
      other (> 100bp), then the closest position is picked.
      If not, the position is reported.
    - After this, all mappings are counted by their coverage and
      reported.

Possible to do:
- Multiple 5' UTR *or* multiple 3' UTR mappings are all counted if these
are the only mappings. Perhaps we should pick the closest, like as if
both UTR mappings were present.



10) Now, it's time to try and find alternative Open Reading Frames (ORFs). The
find_ORFs.php script tries to identify "peaks" in the coverage pattern as
alternative open reading frame starts, depending on the coverage of the
surrounding region.
Usage:
./find_ORFs.php <MUTALYZER_RESULTS> <WIGGLE_FILE> <GENE_LIST_FILE> <STRAND>

Example:
./find_ORFs.php F.wig5_mutalyzer_batchfile_results.txt F.wig5 \
  mm10_gene_list.txt F
(Valid values for Strand: +, -, F and R)

The script does the following things:
+ Read out the coverage information from the Wiggle file
+ Read the gene list to find out which genes (transcripts, actually) are on
  which strand
+ Read the Mutalyzer result file to see which locations map to which
  transcripts, determining the position within the transcript
  * Filter low coverage positions (< 3)
  * Mappings on non-coding transcripts are ignored
  * Mappings on transcripts on the other strand are ignored
  * Transcripts not in the gene list are ignored and reported (so they could be
    fixed == added to the gene info file)
  * Filter positions without transcript mapping
  * Filter positions with only intronic mapping
  * Filter positions too far from transcript start or stop sites (> 500bp)
  * The remaining possible mappings are processed.
    - 5' UTR or 3' UTR mappings, while exonic mappings are also available, are
      discarded.
    - If there are 5' UTR and 3' UTR mappings, but none in the exon region, we
      assume an intergenic situation and if one of the two positions is clearly
      closer to the translated region than the other (> 100bp), then the closest
      position is picked. If not, the position is reported.
    - After this, all positions are stored, per gene, for the next step.
+ Genes with less than 3 reads aligned to it, are ignored.
+ Peaks are searched for by comparing them to the surrounding area.
  * Known peaks (-15, -12, -9, -6 and -3) are never discarded, because we want
    to show them always.
  * Each position with coverage is compared to its direct neighbouring
    nucleotides (-1, +1). If the coverage is not at least 10 reads higher, or
    when the coverage is not at least a factor 2 higher, the position is
    discarded.
  * Each position with coverage is compared to the average coverage of the
    surrounding region (currently defined as -5 to +5 nucleotides). If the
    coverage is not at least a factor 10 higher, the position is discarded.
  * Exonic background is filtered out.
    ============================================================================
    NOTE: This is currently done by simply removing all positions that are in
    the exonic region (>= than 1 and < than *1) as candidates. However, it is
    planned to be done as follows:
    ============================================================================
    This is done by comparing the coverage of each exonic position to the
    average of all positions in this frame. So for position one, the coverage
    should be compared to the average of the coverage for positions (1, 4, 7,
    10, 13, etc). For position 2 we need to compare to 2, 5, 8, 11, 14, etc.
    Problem: Do we need to guess the length of the transcript, or will we take
    the length of where we see coverage to calculate the average? We could do
    so, by looping from the highest position backwards, and store the highest
    peak position that is exonic (not 3' UTR).
    If a position's coverage is not at least a factor 2 higher than this
    average, the position is discarded.
+ Genes that have no candidate peaks left, are ignored.
+ For all genes remaining, the positions are reported relative to all known
  transcripts of the gene in question. The original number of positions is
  mentioned along with the number of remaining candidate peaks.
  Results are displayed as: position, coverage, position on transcript.
  The last column may be repeated, depending on the number of known transcripts.

Possible to do:
- When the possible peak is compared to the surrounding positions, the strand is
  currently ignored, we can improve that.
- The region surrounding the position that the position's coverage is compared
  to, is based on genomic coordinates, and not RNA coordinates. This could lead
  to false positives because we might be comparing to intronic sequence.
- Actually implement the exonic filtering? Is the proposed method OK?
- Exonic filtering against background measured per frame, so we can find
  alternative frames?
- Since we don't expect coverage in the last exons (except in really large
  genes), we will not estimate the transcript length correctly, and all will be
  filtered out?



11) Now, the ORF files need to be grouped, per strand (F and R). The
merge_ORF_files.php script merges the files for you into one summary file, but
does not take care of the strands, so you need to make sure you don't mix
forward and reverse files with each other.
Usage:
./merge_ORF_files.php ORF_FILE1 [ORF_FILE2 [ORF_FILE3 [...]]]

Example:
./merge_ORF_files.php *.F.*_ORF_analysis.txt

The script analyses the file names to isolate the sample IDs. It assumes that
the sample IDs are the only differences between the input file names. The sample
IDs are also used in the headers of the output.

While grouping, it ignores the positions of the peaks on the transcripts. It
only reports the chromosomal position, per sample the coverage, and then as a
last column the gene name.

Example output:
# Chromosome    Position    A1    A2    A3    C1    C2    C3    Gene
chr1            4857920     32    14    27     0     0    10    Tcea1
chr1            4857929     24     0    24     0     0     0    Tcea1

